# 正文

> 对正则表达式学习以及整理的总结性资料，也用来复习相关知识

## 基本组成元素

分为字符和元字符

字符就是基础的计算机字符编码，比如数字，英文字母等。

而元字符也被称为特殊字符，是一些用来表示特殊语义的字符。特别是 **/**,用来对特殊字符进行转义，从而匹配

### 元字符

| 特殊字符   | 正则表达式 | 描述                                      |
| ---------- | ---------- | ----------------------------------------- |
| 换行符     | \n         | 换一行 new line                           |
| 换页符     | \f         | 暂无                                      |
| 回车符     | \r         | return                                    |
| 空格符     | \s         | space                                     |
| 制表符     | \t         | tab                                       |
| 垂直制表符 | \v         | vertical tab                              |
| 回退符     | [\b]       | backspace,之所以使用[]符号是避免和\b 重复 |

## 多个字符

单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。

在正则表达式里，集合的定义方式是使用中括号 **[** 和 **]** 。如 **/[123]/** 这个正则就能同时匹配 1,2,3 三个字符。那如果我想匹配所有的数字怎么办呢？从 0 写到 9 显然太过低效，所以元字符-就可以用来表示区间范围，利用 **/[0-9]/** 就能匹配所有的数字, **/[a-z]/** 则可以匹配所有的英文小写字母。

列举一批用来同时匹配多个字符的简便正则表达式：

| 匹配区间                                      | 正则表达式 | 记忆方式                     |
| --------------------------------------------- | ---------- | ---------------------------- |
| 除了换行符之外的任何字符                      | .          | 英文句号                     |
| 单个数字, [0-9]                               | \d         | 也就是数字的简称             |
| 除了数字                                      | \D         | 也就是非数字                 |
| 包括下划线在内的单个字符，[A-Za-z0-9_]        | \w         | 也就是字母数字和下划线都包含，单词字符 |
| 非单字字符                                    | \W         | 非单词字符                     |
| 匹配空白字符,包括空格、制表符、换页符和换行符 | \s         | 也就是匹配上面的特殊字符     |
| 匹配非空白字符                                | \S         | 也就是基础的字符都包括       |

## 循环与重复

要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为 0 次，1 次，多次，特定次。

### 0 | 1

元字符 **?** 代表了匹配一个字符或 0 个字符。设想一下，如果你要匹配 color 和 colour 这两个单词，就需要同时保证 u 这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：**/colou?r/**。

### >= 0

元字符 **\*** 用来表示匹配 0 个字符或无数个字符。通常用来过滤某些可有可无的字符串。

### >= 1

元字符+适用于要匹配同个字符出现 1 次或多次的情况。

## 特定次数

在某些情况下，我们需要匹配特定的重复次数，元字符 **{** 和 **}** 用来给重复匹配设置精确的区间范围。如'a'我想匹配 3 次,那么我就使用 **/a{3}/** 这个正则，或者说'a'我想匹配至少两次就是用 **/a{2,}/** 这个正则。

以下是完整的语法：

```(特定次数语法)
-{x}: x 次

-{min, max}： 介于 min 次到 max 次之间

-{min, }: 至少 min 次

-{0, max}： 至多 max 次
```

## 位置边界

### 单词边界

单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如：

```(举例)
The cat scattered his food all over the room.
```

复制代码我想找到 cat 这个单词，但是如果只是使用 **/cat/** 这个正则，就会同时匹配到 cat 和 scattered 这两处文本。这时候我们就需要使用边界正则表达式 **\b**，其中 b 是 boundary 的首字母。在正则引擎里它其实匹配的是能构成单词的字符 **(\w)** 和不能构成单词的字符 **(\W)** 中间的那个位置。
上面的例子改写成/\bcat\b/这样就能匹配到 cat 这个单词了。

**\b**是单词边界，具体就是 **\w** 和 **\W** 之间的位置，也包括 **\w** 和 **^** 之间的位置，也包括 **\w** 和 **$** 之间的位置。比如一个文件名是`"[JS] Lesson_01.mp4"`中的 **\b**，如下：

```()
var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
console.log(result);
// => "[#JS#] #Lesson_01#.#mp4#"
```

**\B** 就是 **\b** 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 **\b**，剩下的都是 **\B** 的。具体说来就是 **\w** 与 **\w**、**\W** 与 **\W**、**^** 与 **\W**，**\W** 与 **$** 之间的位置。比如上面的例子，把所有 **\B** 替换成"#"：

```()
var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');
console.log(result);
// => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

### 字符串边界

元字符^用来匹配字符串的开头。而元字符\$用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。

我们可以使用 **/^I am scq000\.\$/m** 这样的正则表达式，其实 m 是 multiple line 的首字母。正则里面的模式除了 m 外比较常用的还有 i 和 g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。

| 边界和标志 | 正则表达式 | 记忆方式                 |
| ---------- | ---------- | ------------------------ |
| 单词边界   | \b         | boundary                 |
| 非单词边界 | \B         | not boundary             |
| 字符串开头 | ^          | 从哪里开始               |
| 字符串结尾 | \$         | 到哪里结束               |
| 多行模式   | m          | 匹配多行中的文本         |
| 忽略大小写 | i          | 省略字母的大小写关系     |
| 全局模式   | g          | 全部匹配，可不止一个结果 |

### 锚字符

在ES5中，共有6个锚字符：

```(举例)
^ $ \b \B (?=p) (?!p)
```

#### ^和$

^（脱字符）匹配开头，在多行匹配中匹配行开头。$（美元符号）匹配结尾，在多行匹配中匹配行结尾。比如我们把字符串的开头和结尾用"#"替换（位置可以替换成字符的！）：

```(举例)
var result = "hello".replace(/^|$/g, '#');
console.log(result);
// => "#hello#"
```

我们知道匹配开头可以使用^，但要求这个位置不是开头怎么办？
easy，**(?!^)**

多行匹配模式时，二者是行的概念，这个需要我们的注意：

```()
var result = "I\nlove\njavascript".replace(/^|$/gm, '#');
console.log(result);
/*
#I#
#love#
#javascript#
*/
```

#### (?=p)和(?!p)

**(?=p)**，其中p是一个子模式，即p前面的位置。比如(?=l)，表示'l'字符前面的位置，例如：

```()
var result = "hello".replace(/(?=l)/g, '#');
console.log(result);
// => "he#l#lo"
```

复制代码而(?!p)就是(?=p)的反面意思，比如：

```()
var result = "hello".replace(/(?!l)/g, '#');
console.log(result);
// => "#h#ell#o#"
```

这里记忆时，可以先计算 **(?=RegExp)** ，剩下的都是 **(?!RegExp)**的位置。

字符之间的位置，可以写成多个。

把位置理解空字符，是对位置非常有效的理解方式。

## 子表达式（高级模式）

从简单到复杂的正则表达式演变通常要采用分组、回溯引用和逻辑处理的思想。利用这三种规则，可以推演出无限复杂的正则表达式。

### 分组

其中分组体现在：所有以 **(** 和 **)** 元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。

### 回溯引用

所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像 **\1**,**\2**,....,其中 **\1** 表示引用的第一个子表达式，**\2**表示引用的第二个子表达式，以此类推。而 **\0**则表示整个表达式。

回溯引用在替换字符串中十分常用，语法上有些许区别，用$1,$2...来引用要被替换的字符串。下面以 js 代码作演示：

```(举例)
var str = 'abc abc 123';
str.replace(/(ab)c/g,'$1g');
// 得到结果 'abg abg 123'
```

如果我们不想子表达式被引用，可以使用非捕获正则(?:regex)这样就可以避免浪费内存。

```(举例)
var str = 'scq000'.
str.replace(/(scq00)(?:0)/, '$1,$2')
// 返回scq00,$2
// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2
```

如果我们不想子表达式被引用，可以使用非捕获正则(?:regex)这样就可以避免浪费内存。

```(举例)
var str = 'scq000'.
str.replace(/(scq00)(?:0)/, '$1,$2')
// 返回scq00,$2
// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$.
```

**\10** 表示什么呢？另外一个疑问可能是，即\10是表示第10个分组，还是\1和0呢？答案是前者，虽然一个正则里出现\10比较罕见。测试如下：

```()
var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/;
var string = "123456789# ######"
console.log( regex.test(string) );
// => true
```

引用不存在的分组会怎样？

因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如 **\2**，就匹配 **"\2"**。注意 **"\2"**表示对 **"2"**进行了转意。

有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。

#### 前向查找

前向查找(lookahead)是用来限制后缀的。凡是以 **(?=regex)** 包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如 happy happily 这两个单词，我想获得以 happ 开头的副词，那么就可以使用 **happ(?=ily)** 来匹配。如果我想过滤所有以 happ 开头的副词，那么也可以采用负前向查找的正则 **happ(?!ily)**，就会匹配到 happy 单词的 happ 前缀。

#### 后向查找

介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： apple和people都包含ple这个后缀，那么如果我只想找到apple的ple，该怎么做呢？我们可以通过限制app这个前缀，就能唯一确定ple这个单词了。

```(举例)
/(?<=app)ple/
```

其中 **(?<=regex)** 的语法就是我们这里要介绍的后向查找。regex指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向后查找。另外一种限制匹配是利用 **(?<!regex)** 语法，这里称为负后向查找。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找apple的ple也可以这么写成 **/(?<!peo)ple**。

回溯查找 | 正则 | 记忆方式
---------|----------|---------
 引用 | \0,\1,\2 和 $0, $1, $2 | 转义+数字
 非捕获组 | (?:) | 引用表达式(()), 本身不被消费(?),引用(:)
 前向查找 | (?=) | 引用子表达式(())，本身不被消费(?), 正向的查找(=)
 前向负查找 | (?!) | 引用子表达式(())，本身不被消费(?), 正向的查找(=)
 后向查找 | (?<=) | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=)
 后向负查找 | (?<!) | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!)

## 逻辑处理

在正则里面，默认的正则规则都是与的关系所以这里不讨论。
而非关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用 **^** 这个元字符。在这里要着重记忆一下：只有在 **[** 和 **]** 内部使用的 **^** 才表示非的关系。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式 **(?!regex)** 或后向负查找子表达式 **(?<!regex)**。
或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用 **(a|b)** 这样的子表达式。

逻辑关系 | 正则元字符
---------|----------
 与 | 无
 非 | [^regex]和!
 或 | \||

## 量词简写形式

```(举例)
{m,} 表示至少出现m次。
{m} 等价于{m,m}，表示出现m次。
? 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？
+ 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
* 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。
```

### 贪婪匹配和惰性匹配

看如下的例子：

```(举例)
var regex = /\d{2,5}/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) );
// => ["123", "1234", "12345", "12345"]
```

复制代码其中正则 **/\d{2,5}/**，表示数字连续出现2到5次。会匹配2位、3位、4位、5位连续数字。但是其是贪婪的，它会尽可能多的匹配。你能给我6个，我就要5个。你能给我3个，我就3要个。反正只要在能力范围内，越多越好。我们知道有时贪婪不是一件好事（请看文章最后一个例子）。而惰性匹配，就是尽可能少的匹配：

```(举例)
var regex = /\d{2,5}?/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) );
// => ["12", "12", "34", "12", "34", "12", "34", "56"]
```

复制代码其中/\d{2,5}?/表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了。通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：

```(举例)
{m,n}?
{m,}?
??
+?
*?
```

对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？

## 正则表达式的拆分

JS正则表达式中，都有哪些结构呢？

```()
字面量，匹配一个具体字符，包括不用转义的和需要转义的。比如a匹配字符"a"，又比如\n匹配换行符，又比如\.匹配小数点。
字符组，匹配一个字符，可以是多种可能之一，比如[0-9]，表示匹配一个数字。也有\d的简写形式。另外还有反义字符组，表示可以是除了特定字符之外任何一个字符，比如[^0-9]，表示一个非数字字符，也有\D的简写形式。
量词，表示一个字符连续出现，比如a{1,3}表示“a”字符连续出现3次。另外还有常见的简写形式，比如a+表示“a”字符连续出现至少一次。
锚点，匹配一个位置，而不是字符。比如^匹配字符串的开头，又比如\b匹配单词边界，又比如(?=\d)表示数字前面的位置。
分组，用括号表示一个整体，比如(ab)+，表示"ab"两个字符连续出现多次，也可以使用非捕获分组(?:ab)+。
分支，多个子表达式多选一，比如abc|bcd，表达式匹配"abc"或者"bcd"字符子串。
反向引用，比如\2，表示引用第2个分组。
```

其中涉及到的操作符有：

```()
1.转义符 \
2.括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...]
3.量词限定符 {m}、{m,n}、{m,}、?、*、+
4.位置和序列 ^ 、$、 \元字符、 一般字符
5. 管道符（竖杠）|
```

上面操作符的优先级从上至下，由高到低。
