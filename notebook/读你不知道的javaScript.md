# 正文

> 一本好书是值得反复阅读的,并且每次都能从中获取新的知识

## 作用域

首先了解下编译原理: 分词/词法分析,解析/语法分析,代码生成.而在实际意义中,编译器在之后,引擎执行时,会对变量进行查找,该查找过程,确定了执行的结果

其中,LHS进行的是当变量出现在赋值操作的左侧时进行的查询,RHS则相反.

而这两种查找在查询失败时产生的错误也不同,RHS会爆出**ReferenceError**错误,而LHS则在严格模式下同样会爆该错误,还有一种错误是**TypeError**.

**ReferenceError**同作用域判别失败相关,而**TypeError**则代表作用域判别成功,但是对结果的操作是非法或不合理的.

### 词法作用域

其实质就是作用域编写出来的代码被编译器解析的过程中由函数声明的位置来决定

当然,也可以欺骗作用域达到修改词法作用域的目的.但这两种情况要视情况而定.

### 函数作用域

含义是指:属于这个函数的全部变量都可以在这个函数的范围内(以及嵌套的作用域中)使用及复用

而IIFE则指立即执行函数表达式.

* 其作用为当做函数调用并传递参数进去,可以改变代码风格,动态命名全局变量.
* 也可以解决undefined标识符的默认值被错误覆盖导致的异常,将一个参数命名为undefined,但在对应的位置不传入任何值,则就能保证undefined标识符真的是undefined.
* 还有一种用途是倒置代码的运行顺序,将需要运行的函数放在第二位,这种方式在UMD项目中被广泛使用

```
(function IIFE( def ){
    def(window)
})(function def(global){
    ...
});
```

### 块作用域

在for或者if中调用变量,会发现内部定义的变量变为了全局变量,因此,想要使用块级作用域,需要额外的实现,而在es6中,首次出现了块级作用域的概念.

ES5中可以通过**with()**,**try/catch**等方式创建一个内部的块级作用域.

## 声明提升

在javascript中,包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理,这是编译阶段的工作.

这个过程就好像变量和函数声明从它们在代码中出现的位置被移动到了最上面,这个过程就叫做提升.

## 值

### 数字

因为javaScript遵循的是**IEEE 754**规范,所以会出现如下情况:

```数字
0.1+0.2 !== 0.3
```

实际是在转换为二进制时,双精度浮点数的小数部分最多支持52位,所以计算机自动进行了舍入,从而得到了0.30000000000000004,所以条件为false.

处理方法也很简单,既然浮点数处理会自动舍入,那么转为整数,在处理或判断之后再转为小数,就能达到要求了.

而在书里也介绍了一种方法,通过误差范围值(机器密度[machine epsilon]),来进行比较.

ES6中将该值定义在**Number.EPSILON**中,也可以为之前的版本写polyfill:

```polyfill
if(!Number.EPSILON){
    Number.EPSILON = Math.pow(2,-52);
}

function numbersCloseEnoughToEqual(n1,n2){
    return Math.abs( n1 - n2 ) < Number.EPSILON
}
```

### void

该表达式只是为了不返回值,所以**void XXX = undefined**,

### NaN

表示不是数字的数字,其是一个无效数值或失败数值,唯一一个非自反的值,但**NaN != NaN**却为true.通常使用Number.isNaN()来进行判断,但这种判断只在大多数情况下生效.

### 无穷数 Infinity

当运算结构溢出时,结果就为 Infinity 或 -Infinity

### 特殊等式

ES6中新增了一个方法**Object.is(...)**来判断两个值是否绝对相等.

其polyfill为:

```polyfill
if(!Object.is){
    Object.is = function(v1,v2){
        // 判断是否是 -0
        if(v1 === 0 && v2 === 0){
            return 1 / v1 === 1 / v2
        }
        // 判断是否是NaN
        if(v1 !== v1){
            return v2 !== v2;
        }
        // 其他情况
        return v1 === v2;
    }
}
```

### 值与引用

JavaScript中的引用不能指向别的变量/引用,只能指向值

## 原生函数

### 内部属性 [[class]]

**object.prototype.toString.call("abc")**,实际返回的是内部的**[[class]]**属性值